{
    "collab_server" : "",
    "contents" : "# library(bnlearn)\n# library(self)\n# nodes=c(20,30,40,50,60)\n# result<-c()\n# for(j in 6:10){\n#   for(i in 1:5){\n#     set.seed(j)\n#     n=nodes[i]\n#     G=matrix(0,nrow = n,ncol = n)\n#     for(k in 2:n){\n#       G[sample(1:(k-1),1),k]<-1\n#     }\n#     data=synthetic_data_linear(G,sample_num = 4000)\n#     fitG<-fhc(data,min_increase=0.01,booster = \"gblinear\",alpha=20,lambda=10,save_model=FALSE,nthread=3)\n#     term=data.frame(indicators(fitG,G),type=\"linear\",method=\"SELF\")\n#     result<-rbind(result,term)\n#     print(result)\n#     term=data.frame(indicators(amat(hc(data,score=\"bic-g\")),G),type=\"linear\",method=\"hc-bic-g\")\n#     result<-rbind(result,term)\n#     print(result)\n#   }\n# }\n#\n#\n#\n# library(bnlearn)\n# library(self)\n# nodes=c(20,30,40,50,60)\n# result<-c()\n# for(j in 6:10){\n#   for(i in 1:5){\n#     set.seed(j)\n#     n=nodes[i]\n#     G=matrix(0,nrow = n,ncol = n)\n#     for(k in 2:n){\n#       G[sample(1:(k-1),1),k]<-1\n#     }\n#     data=synthetic_data_nonlinear(G,sample_num = 4000)\n#     fitG<-fhc(data,min_increase=0.02,gamma=10,save_model=FALSE,nthread=3)\n#     term=data.frame(indicators(fitG,G),type=\"nonlinear\",method=\"SELF\")\n#     result<-rbind(result,term)\n#     print(result)\n#   }\n# }\n\ndistinguishableEdge<-function(G){\n  n=ncol(G)\n  v=0\n  for(k in 1:n){\n    pa=which(G[,k]==1)\n    if(length(pa)>1){\n      subG<-G[pa,pa]\n      idx<-which(subG==0,arr.ind=TRUE)\n      idx<-as.data.frame(idx)\n      idx<-idx%>%filter(row<col) #找到子图上三角中为0的元素，\n      edge=uniqueN(c(idx$row,idx$col)) #v表示能用v结构判别方向的边的数量\n      v=v+edge\n    }\n  }\n  return(v)\n}\nnv<-function(G){\n  n=ncol(G)\n  v=0\n  for(k in 1:n){\n    pa=which(G[,k]==1)\n    if(length(pa)>1){\n      subG<-G[pa,pa]\n      idx<-which(subG==0,arr.ind=TRUE)\n      idx<-as.data.frame(idx)\n      idx<-idx%>%filter(row<col) #找到子图上三角中为0的元素\n      if(nrow(idx)!=0){\n        v=v+1\n      }\n    }\n  }\n  return(v)\n}\ndelV<-function(G,nodes=1:ncol(G),times=1){\n\n  count=0\n  for(k in nodes){\n    pa=which(G[,k]==1)\n    if(length(pa)>1){\n      subG<-G[pa,pa]\n      idx<-which(subG==0,arr.ind=TRUE)\n      idx<-as.data.frame(idx)\n      idx<-idx%>%filter(row<col) #找到子图上三角中为0的元素\n      node<-unique(c(idx$row,idx$col))\n      #sel<-node[-sample(1:length(node),1)] #随机保留一个结点，然后把其他结点对应的边都删了\n      sel<-node[-1]\n      #edge=length(node) #v表示能用v结构判别方向的边的数量\n      G[pa[sel],k]<-0 #把其他结点对应的边都删了\n      count=count+1\n      if(count>times){\n        return(G)\n      }\n    }\n  }\n  return(G)\n}\ndelAllV<-function(G,nodes=1:ncol(G)){\n  times<-nv(G)+1\n  count=0\n  for(k in nodes){\n    pa=which(G[,k]==1)\n    if(length(pa)>1){\n      subG<-G[pa,pa]\n      idx<-which(subG==0,arr.ind=TRUE)\n      idx<-as.data.frame(idx)\n      idx<-idx%>%filter(row<col) #找到子图上三角中为0的元素\n      node<-unique(c(idx$row,idx$col))\n      #sel<-node[-sample(1:length(node),1)] #随机保留一个结点，然后把其他结点对应的边都删了\n      sel<-node[-1]\n      #edge=length(node) #v表示能用v结构判别方向的边的数量\n      G[pa[sel],k]<-0 #把其他结点对应的边都删了\n      count=count+1\n      if(count>times){\n        return(G)\n      }\n    }\n  }\n  return(G)\n}\nrest_edge<-function(seed){\n  set.seed(seed)\n  G=randomGraph(40,1.5)\n  #v1<-nv(G)\n  G2<-delAllV(G)\n  #v2=nv(G2)\n  return(sum(G2))\n}\n\n\nlibrary(pcalg)\nlibrary(bnlearn)\nlibrary(self)\nlibrary(dplyr)\nlibrary(data.table)\nresult=c()\nfor(j in 2:10){\n  set.seed(j)\n  n=40\n  G=randomGraph(n,1.5)\n  start=nv(G)\n  step=round(start/5)\n  newG=G\n  n=nv(G)\n  for(i in 1:5){\n    print(nv(newG))\n    set.seed(j)\n    data=synthetic_data_linear(newG,4000)\n    fitG<-fhc(data,min_increase=0.01,booster = \"lm\")\n    term=data.frame(indicators(fitG,newG),type=\"linear\",method=\"SELF\",percent=0.25*(i-1))\n    result<-rbind(result,term)\n    fitG<-lingam(data)\n    fitG<-as(fitG,\"amat\")\n    term=data.frame(indicators(fitG,newG),type=\"linear\",method=\"ICA-LiNGAM\",percent=0.25*(i-1))\n    result<-rbind(result,term)\n    fitG<-amat(hc(data,score=\"bic-g\"))\n    term=data.frame(indicators(fitG,newG),type=\"linear\",method=\"hc-bic-g\",percent=0.25*(i-1))\n    result<-rbind(result,term)\n    newG=delV(newG,times = step)\n    print(result)\n  }\n}\nlibrary(foreach)\nlibrary(doParallel)\ncl<-makeCluster(4)\nregisterDoParallel(cl)\nresult<-foreach(j = 1:10, .combine = rbind,.packages=c(\"self\",\"data.table\",\"dplyr\"))%dopar%{\n  set.seed(j)\n  n=40\n  G=randomGraph(n,1.5)\n  start=nv(G)\n  step=round(start/5)\n  newG=G\n  n=nv(G)\n  for(i in 1:5){\n    print(nv(newG))\n    set.seed(j)\n    data=synthetic_data_nonlinear(newG,4000)\n    #fitG<-fhc(data,min_increase=0.01,booster = \"gbtree\",nthread=5)\n    fitG<-mmpcAnm(data)\n    #term=data.frame(indicators(fitG,newG),type=\"nonlinear\",method=\"SELF\",percent=0.25*(i-1))\n    term=data.frame(indicators(fitG,newG),type=\"nonlinear\",method=\"MMPC-ANM\",percent=0.25*(i-1))\n    result<-rbind(result,term)\n    newG=delV(newG,times = step)\n    #print(result)\n  }\n  result\n}\n\nlibrary(foreach)\nlibrary(doParallel)\ncl<-makeCluster(6)\nregisterDoParallel(cl)\nresult2<-foreach(j = 1:10, .combine = rbind,.packages=c(\"self\",\"data.table\",\"dplyr\"),.export = c(\"nv\",\"delV\"))%dopar%{\n#for(j in 1:10){\n  set.seed(j)\n  n=40\n  G=randomGraph(n,1.5)\n  start=nv(G)\n  step=round(start/5)\n  newG=G\n  n=nv(G)\n  for(i in 1:5){\n    print(nv(newG))\n    set.seed(j)\n    data=synthetic_data_nonlinear(newG,4000)\n    fitG<-fhc(data,min_increase=0.01,gamma=10,booster = \"gbtree\",nthread=1)\n    #fitG<-mmpcAnm(data)\n    term=data.frame(indicators(fitG,newG),type=\"nonlinear\",method=\"SELF\",percent=0.25*(i-1))\n    #term=data.frame(indicators(fitG,newG),type=\"nonlinear\",method=\"MMPC-ANM\",percent=0.25*(i-1))\n    result<-rbind(result,term)\n    newG=delV(newG,times = step)\n    print(result)\n  }\n}\n\n#输出数据\nfor(j in 1:10){\n  set.seed(j)\n  n=40\n  G=randomGraph(n,1.5)\n  start=nv(G)\n  step=round(start/5)\n  newG=G\n  n=nv(G)\n  for(i in 1:5){\n    set.seed(j)\n    data=synthetic_data_linear(newG,4000)\n    fwrite(data,paste0(\"data_j\",j,\"_i\",i,\".csv\"),col.names=F)\n    fwrite(as.data.frame(newG),paste0(\"data_j\",j,\"_i\",i,\"_G.csv\"),col.names=F)\n    newG=delV(newG,times = step)\n  }\n}\n",
    "created" : 1504881280663.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "135229244",
    "id" : "54FD07D2",
    "lastKnownWriteTime" : 1501421592,
    "last_content_update" : 1501421592,
    "path" : "~/zhengproj/R/Project/zheng_project/mbexp.R",
    "project_path" : null,
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 11,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}