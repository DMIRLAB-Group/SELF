{
    "collab_server" : "",
    "contents" : "#' @title Calculate the f1,precision,recall score of the graph\n#' @description Calculate the f1,precision,recall score of the graph\n#' @param pred Your predicted graph\n#' @param real Your real graph\n#' @return f1,precision,recall score.\n#' @export\n#' @examples\n#' pred<-matrix(c(0,0,0,0,1,0,1,1,0),nrow=3,ncol=3)\n#' real<-matrix(c(0,0,0,0,1,0,1,0,0),nrow=3,ncol=3)\n#' indicators(pred,real)\nindicators<-function(pred,real){\n  TP=sum((real==1)&(pred==1))\n  FN=sum((real==1)&(pred==0))\n  FP=sum((real==0)&(pred==1))\n  TN=sum((real==0)&(pred==0))\n  recall=TP/(TP+FN)\n  precision=TP/(TP+FP)\n  F1=2*precision*recall/(precision+recall)\n  data.frame(recall,precision,F1)\n}\nparents<-function(G,i){\n  which(G[,i]==1)\n}\ncompareG<-function(G1,G2){\n  which(colSums(abs(G1-G2))>0)\n}\n\n#' @title Generate a random graph\n#' @description Generate a random graph based on the given dimension size and indegree\n#' @param dim The random graph dimension\n#' @param indegree The random graph indegree for each nodes\n#' @return Return a random graph\n#' @export\n#' @examples\n#' randomGraph(5,2)\nrandomGraph<-function(dim,indegree){\n  G<-matrix(0,nrow=dim,ncol=dim)\n  repeat{\n    r=rbinom((dim*dim-dim)/2,1,indegree*2/(dim-1))\n    if(sum(r)/dim==indegree){\n      G[upper.tri(G)]<-r\n      return(G)\n    }\n  }\n\n  # for(i in 2:dim){\n  #   if(i<=indegree){\n  #     G[1:(i-1),i]=1\n  #   }else{\n  #     G[]\n  #     G[sample.int(i-1,indegree),i]=1\n  #   }\n  # }\n  #return(G)\n}\n#' @title synthetic nonlinear data base on the graph\n#' @description synthetic nonlinear data base on the graph. The data generation mechanism is y=scale(a1b1x^2+a2b2x^3+a3b3x^4+a4b4sin(x)+a5b5sin(x^2))\n#' @param G An adjacency matrix.\n#' @param sample_num The number of samples you want to synthetic\n#' @param ratio The noise ratio. It will grow or shrink the value of the noise\n#' @param return_noise Will return  the each node of the noise in the generating process for further analysis.\n#' @return Return a synthetic data\n#' @export\n#' @examples\n#' G<-matrix(c(0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0),nrow = 4,ncol = 4)\n#' data=synthetic_data_nonlinear(G,500)\nsynthetic_data_nonlinear<-function(G,sample_num,ratio=1,return_noise=FALSE){\n  f<-function(x){\n    return(data.frame(x^2,x^3,x^4,sin(x),sin(x^2)))\n  }\n  if(return_noise){\n    noise=data.frame()\n  }\n  if(is.null(colnames(G))){\n    g<-empty.graph(paste0(\"V\",1:ncol(G)))\n  }else{\n    g<-empty.graph(colnames(G))\n  }\n  amat(g)<-G\n  order<-node.ordering(g)\n  data<-matrix(0,nrow=sample_num,ncol=length(order))\n  if(is.null(colnames(G))){\n    colnames(data)<-paste0(\"V\",1:ncol(G))\n  }else{\n    colnames(data)<-colnames(G)\n  }\n\n  #pb <- txtProgressBar(0,length(order),style = 3)\n  for(i in 1:length(order)){\n    #setTxtProgressBar(pb, i)\n    if(length(g$nodes[[order[i]]]$parents)==0){\n      data[,order[i]]<-runif(sample_num,-1,1)*ratio\n      if(return_noise){\n        if(ncol(noise)==0){\n          noise=data.frame(data[,order[i]])\n        }else{\n          noise=cbind(noise,data[,order[i]])\n        }\n      }\n    }else{\n      parents=g$nodes[[order[i]]]$parents\n      x=data[,parents,drop=F]\n      for(p in parents){\n        a=runif(5,-3,3)\n        b=rbinom(5,1,0.5)\n        b[round(runif(1,1,5))]<-1\n        a=a[b==1]\n        data[,order[i]]<-data[,order[i]]+scale(t(t(a)%*%t(as.matrix(f(x[,p])[,b==1]))))\n      }\n      ei=runif(sample_num,-1,1)*ratio\n      data[,order[i]]<-data[,order[i]]+ei\n      if(return_noise){\n        if(ncol(noise)==0){\n          noise=data.frame(ei)\n        }else{\n          noise=cbind(noise,data.frame(ei))\n        }\n      }\n    }\n  }\n  if(return_noise){\n    return(list(data=as.data.frame(data),noise=noise))\n  }else{\n    return(as.data.frame(data))\n  }\n\n}\n\n#' @title synthetic linear data base on the graph\n#' @description synthetic linear data base on the graph. The noise is sample from super-gaussian distribution. And the coefficient is sample from U(-1,-0.5),U(0.5,1)\n#' @param G An adjacency matrix.\n#' @param sample_num The number of samples you want to synthetic\n#' @param ratio The noise ratio It will grow or shrink the value of the noise\n#' @param return_noise Will return  the each node of the noise in the generating process for further analysis.\n#' @return Return a synthetic data\n#' @export\n#' @examples\n#' G<-matrix(c(0,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0),nrow = 4,ncol = 4)\n#' data=synthetic_data_linear(G,500)\nsynthetic_data_linear<-function(G,sample_num,ratio=1,return_noise=FALSE){\n  if(is.null(colnames(G))){\n    g<-empty.graph(paste0(\"V\",1:ncol(G)))\n  }else{\n    g<-empty.graph(colnames(G))\n  }\n  if(return_noise){\n    noise=data.frame()\n  }\n  amat(g)<-G\n  order<-node.ordering(g)\n  data<-matrix(0,nrow=sample_num,ncol=length(order))\n  if(is.null(colnames(G))){\n    colnames(data)<-paste0(\"V\",1:ncol(G))\n  }else{\n    colnames(data)<-colnames(G)\n  }\n\n\n  #pb <- txtProgressBar(0,length(order),style = 3)\n  for(i in 1:length(order)){\n    #setTxtProgressBar(pb, i)\n    if(length(g$nodes[[order[i]]]$parents)==0){\n      #data[,order[i]]<-runif(sample_num,-1,1)\n      data[,order[i]]<-rnorm(sample_num)*ratio\n      #data[,order[i]]<-rlnorm(sample_num)\n      if(return_noise){\n        if(ncol(noise)==0){\n          noise=data.frame(data[,order[i]])\n        }else{\n          noise=cbind(noise,data[,order[i]])\n        }\n      }\n    }else{\n      parents=sort(g$nodes[[order[i]]]$parents)\n      x=data[,parents,drop=F]\n      a=runif(length(parents)+1,0.5,1)\n      b=rbinom(length(parents)+1,2,0.5)\n      b[b==0]=-1\n      a=a*b\n      x=data.frame(x,c=1)\n      #data[,order[i]]<-as.matrix(x)%*%a+runif(sample_num,-1,1)*rate\n      e=rnorm(sample_num)\n      s=sign(e)\n      data[,order[i]]<-scale(as.matrix(x)%*%a+s*e^2*ratio)\n      #data[,order[i]]<-as.matrix(x)%*%a+s*e^2*rate\n      #data[,order[i]]<-as.matrix(x)%*%a+rnorm(sample_num)\n      if(return_noise){\n        if(ncol(noise)==0){\n          noise=data.frame(s*e^2*ratio)\n        }else{\n          noise=cbind(noise,s*e^2*ratio)\n        }\n      }\n    }\n  }\n  if(return_noise){\n    return(list(data=as.data.frame(data),noise=noise))\n  }else{\n    return(as.data.frame(data))\n  }\n}\n",
    "created" : 1504237048594.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "2586751817",
    "id" : "FF60D2F6",
    "lastKnownWriteTime" : 1505025657,
    "last_content_update" : 1505025657110,
    "path" : "~/zhengproj/R/Project/self/R/utility_functions.R",
    "project_path" : "R/utility_functions.R",
    "properties" : {
        "docOutlineVisible" : "1"
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}